// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/cobrun/go/pkg/mod/github.com/uber/h3-go/v4@v4.1.2/h3.go:1:1
// Package h3 is the go binding for Uber's H3 Geo Index system.
// It uses cgo to link with a statically compiled h3 library
package h3

/*
 * Copyright 2018 Uber Technologies, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
#cgo CFLAGS: -std=c99
#cgo CFLAGS: -DH3_HAVE_VLA=1
#cgo LDFLAGS: -lm
#include <stdlib.h>
#include <h3_h3api.h>
#include <h3_h3Index.h>
*/
import _ "unsafe"

import (
	"errors"
	"fmt"
	"math"
	"strconv"
	"strings"
	"unsafe"
)

const (
	// MaxCellBndryVerts is the maximum number of vertices that can be used
	// to represent the shape of a cell.
	MaxCellBndryVerts = ( /*line :43:22*/_Ciconst_MAX_CELL_BNDRY_VERTS /*line :43:43*/)

	// MaxResolution is the maximum H3 resolution a LatLng can be indexed to.
	MaxResolution = ( /*line :46:18*/_Ciconst_MAX_H3_RES /*line :46:29*/)

	// The number of faces on an icosahedron
	NumIcosaFaces = ( /*line :49:18*/_Ciconst_NUM_ICOSA_FACES /*line :49:34*/)

	// The number of H3 base cells
	NumBaseCells = ( /*line :52:17*/_Ciconst_NUM_BASE_CELLS /*line :52:32*/)

	// The number of H3 pentagon cells (same at every resolution)
	NumPentagons = ( /*line :55:17*/_Ciconst_NUM_PENTAGONS /*line :55:31*/)

	// InvalidH3Index is a sentinel value for an invalid H3 index.
	InvalidH3Index = ( /*line :58:19*/_Ciconst_H3_NULL /*line :58:27*/)

	base16  = 16
	bitSize = 64

	numCellEdges    = 6
	numEdgeCells    = 2
	numCellVertexes = 6

	DegsToRads = math.Pi / 180.0
	RadsToDegs = 180.0 / math.Pi
)

type (

	// Cell is an Index that identifies a single hexagon cell at a resolution.
	Cell int64

	// DirectedEdge is an Index that identifies a directed edge between two cells.
	DirectedEdge int64

	CoordIJ struct {
		I, J int
	}

	// CellBoundary is a slice of LatLng.  Note, len(CellBoundary) will never
	// exceed MaxCellBndryVerts.
	CellBoundary []LatLng

	// GeoLoop is a slice of LatLng points that make up a loop.
	GeoLoop []LatLng

	// LatLng is a struct for geographic coordinates in degrees.
	LatLng struct {
		Lat, Lng float64
	}

	// GeoPolygon is a GeoLoop with 0 or more GeoLoop holes.
	GeoPolygon struct {
		GeoLoop GeoLoop
		Holes   []GeoLoop
	}
)

func NewLatLng(lat, lng float64) LatLng {
	return LatLng{lat, lng}
}

// LatLngToCell returns the Cell at resolution for a geographic coordinate.
func LatLngToCell(latLng LatLng, resolution int) Cell {
	var i  /*line :108:8*/_Ctype_H3Index /*line :108:17*/

	( /*line :110:2*/_Cfunc_latLngToCell /*line :110:15*/)(latLng.toCPtr(),  /*line :110:34*/_Ctype_int /*line :110:39*/(resolution), &i)

	return Cell(i)
}

// Cell returns the Cell at resolution for a geographic coordinate.
func (g LatLng) Cell(resolution int) Cell {
	return LatLngToCell(g, resolution)
}

// CellToLatLng returns the geographic centerpoint of a Cell.
func CellToLatLng(c Cell) LatLng {
	var g  /*line :122:8*/_Ctype_LatLng /*line :122:16*/

	( /*line :124:2*/_Cfunc_cellToLatLng /*line :124:15*/)( /*line :124:17*/_Ctype_H3Index /*line :124:26*/(c), &g)

	return latLngFromC(g)
}

// LatLng returns the Cell at resolution for a geographic coordinate.
func (c Cell) LatLng() LatLng {
	return CellToLatLng(c)
}

// CellToBoundary returns a CellBoundary of the Cell.
func CellToBoundary(c Cell) CellBoundary {
	var cb  /*line :136:9*/_Ctype_CellBoundary /*line :136:23*/

	( /*line :138:2*/_Cfunc_cellToBoundary /*line :138:17*/)( /*line :138:19*/_Ctype_H3Index /*line :138:28*/(c), &cb)

	return cellBndryFromC(&cb)
}

// Boundary returns a CellBoundary of the Cell.
func (c Cell) Boundary() CellBoundary {
	return CellToBoundary(c)
}

// GridDisk produces cells within grid distance k of the origin cell.
//
// k-ring 0 is defined as the origin cell, k-ring 1 is defined as k-ring 0 and
// all neighboring cells, and so on.
//
// Output is placed in an array in no particular order. Elements of the output
// array may be left zero, as can happen when crossing a pentagon.
func GridDisk(origin Cell, k int) []Cell {
	out := make([] /*line :156:16*/_Ctype_H3Index /*line :156:25*/, maxGridDiskSize(k))
	( /*line :157:2*/_Cfunc_gridDisk /*line :157:11*/)( /*line :157:13*/_Ctype_H3Index /*line :157:22*/(origin),  /*line :157:32*/_Ctype_int /*line :157:37*/(k), &out[0])
	// QUESTION: should we prune zeroes from the output?
	return cellsFromC(out, true, false)
}

// GridDisk produces cells within grid distance k of the origin cell.
//
// k-ring 0 is defined as the origin cell, k-ring 1 is defined as k-ring 0 and
// all neighboring cells, and so on.
//
// Output is placed in an array in no particular order. Elements of the output
// array may be left zero, as can happen when crossing a pentagon.
func (c Cell) GridDisk(k int) []Cell {
	return GridDisk(c, k)
}

// GridDiskDistances produces cells within grid distance k of the origin cell.
//
// k-ring 0 is defined as the origin cell, k-ring 1 is defined as k-ring 0 and
// all neighboring cells, and so on.
//
// Outer slice is ordered from origin outwards. Inner slices are in no
// particular order. Elements of the output array may be left zero, as can
// happen when crossing a pentagon.
func GridDiskDistances(origin Cell, k int) [][]Cell {
	rsz := maxGridDiskSize(k)
	outHexes := make([] /*line :183:21*/_Ctype_H3Index /*line :183:30*/, rsz)
	outDists := make([] /*line :184:21*/_Ctype_int /*line :184:26*/, rsz)
	( /*line :185:2*/_Cfunc_gridDiskDistances /*line :185:20*/)( /*line :185:22*/_Ctype_H3Index /*line :185:31*/(origin),  /*line :185:41*/_Ctype_int /*line :185:46*/(k), &outHexes[0], &outDists[0])

	ret := make([][]Cell, k+1)
	for i := 0; i <= k; i++ {
		ret[i] = make([]Cell, 0, ringSize(i))
	}

	for i, d := range outDists {
		ret[d] = append(ret[d], Cell(outHexes[i]))
	}

	return ret
}

// GridDiskDistances produces cells within grid distance k of the origin cell.
//
// k-ring 0 is defined as the origin cell, k-ring 1 is defined as k-ring 0 and
// all neighboring cells, and so on.
//
// Outer slice is ordered from origin outwards. Inner slices are in no
// particular order. Elements of the output array may be left zero, as can
// happen when crossing a pentagon.
func (c Cell) GridDiskDistances(k int) [][]Cell {
	return GridDiskDistances(c, k)
}

// PolygonToCells takes a given GeoJSON-like data structure fills it with the
// hexagon cells that are contained by the GeoJSON-like data structure.
//
// This implementation traces the GeoJSON geoloop(s) in cartesian space with
// hexagons, tests them and their neighbors to be contained by the geoloop(s),
// and then any newly found hexagons are used to test again until no new
// hexagons are found.
func PolygonToCells(polygon GeoPolygon, resolution int) []Cell {
	if len(polygon.GeoLoop) == 0 {
		return nil
	}
	cpoly := allocCGeoPolygon(polygon)

	defer freeCGeoPolygon(&cpoly)

	maxLen := new( /*line :226:16*/_Ctype_int64_t /*line :226:25*/)
	func() _Ctype_H3Error{ _cgoBase0 := /*line :227:26*/&cpoly; _cgo0 := _cgoBase0; var _cgo1 _Ctype_int = _Ctype_int /*line :227:39*/(resolution); var _cgo2 _Ctype_uint32_t = /*line :227:53*/0; var _cgo3 *_Ctype_int64_t = /*line :227:56*/maxLen; _cgoCheckPointer(_cgoBase0, 0 == 0); return /*line :227:63*/_Cfunc_maxPolygonToCellsSize(_cgo0, _cgo1, _cgo2, _cgo3); }()

	out := make([] /*line :229:16*/_Ctype_H3Index /*line :229:25*/, *maxLen)
	func() _Ctype_H3Error{ _cgoBase0 := /*line :230:19*/&cpoly; _cgo0 := _cgoBase0; var _cgo1 _Ctype_int = _Ctype_int /*line :230:32*/(resolution); var _cgo2 _Ctype_uint32_t = /*line :230:46*/0; var _cgo3 *_Ctype_H3Index = /*line :230:49*/&out[0]; _cgoCheckPointer(_cgoBase0, 0 == 0); return /*line :230:57*/_Cfunc_polygonToCells(_cgo0, _cgo1, _cgo2, _cgo3); }()

	return cellsFromC(out, true, false)
}

// PolygonToCells takes a given GeoJSON-like data structure fills it with the
// hexagon cells that are contained by the GeoJSON-like data structure.
//
// This implementation traces the GeoJSON geoloop(s) in cartesian space with
// hexagons, tests them and their neighbors to be contained by the geoloop(s),
// and then any newly found hexagons are used to test again until no new
// hexagons are found.
func (p GeoPolygon) Cells(resolution int) []Cell {
	return PolygonToCells(p, resolution)
}

// CellsToMultiPolygon takes a set of cells and creates GeoPolygon(s)
// describing the outline(s) of a set of hexagons. Polygon outlines will follow
// GeoJSON MultiPolygon order: Each polygon will have one outer loop, which is first in
// the list, followed by any holes.
//
// It is expected that all hexagons in the set have the same resolution and that the set
// contains no duplicates. Behavior is undefined if duplicates or multiple resolutions are
// present, and the algorithm may produce unexpected or invalid output.
func CellsToMultiPolygon(cells []Cell) []GeoPolygon {
	if len(cells) == 0 {
		return nil
	}
	h3Indexes := cellsToC(cells)
	cLinkedGeoPolygon := new( /*line :259:27*/_Ctype_LinkedGeoPolygon /*line :259:45*/)
	func() _Ctype_H3Error{ var _cgo0 *_Ctype_H3Index = /*line :260:30*/&h3Indexes[0]; var _cgo1 _Ctype_int = _Ctype_int /*line :260:50*/(len(h3Indexes)); _cgo2 := /*line :260:68*/cLinkedGeoPolygon; _cgoCheckPointer(_cgo2, nil); return /*line :260:86*/_Cfunc_cellsToLinkedMultiPolygon(_cgo0, _cgo1, _cgo2); }()
	ret := []GeoPolygon{}

	// traverse polygons for linked list of polygons
	currPoly := cLinkedGeoPolygon
	for currPoly != nil {
		loops := []GeoLoop{}

		// traverse loops for a polygon
		currLoop := currPoly.first
		for currLoop != nil {
			loop := []LatLng{}

			// traverse points for a loop
			currPt := currLoop.first
			for currPt != nil {
				loop = append(loop, latLngFromC(currPt.vertex))
				currPt = currPt.next
			}

			loops = append(loops, loop)
			currLoop = currLoop.next
		}

		ret = append(ret, GeoPolygon{GeoLoop: loops[0], Holes: loops[1:]})
		currPoly = currPoly.next
	}

	return ret
}

// PointDistRads returns the "great circle" or "haversine" distance between
// pairs of LatLng points (lat/lng pairs) in radians.
func GreatCircleDistanceRads(a, b LatLng) float64 {
	return float64(( /*line :294:17*/_Cfunc_greatCircleDistanceRads /*line :294:41*/)(a.toCPtr(), b.toCPtr()))
}

// PointDistKm returns the "great circle" or "haversine" distance between pairs
// of LatLng points (lat/lng pairs) in kilometers.
func GreatCircleDistanceKm(a, b LatLng) float64 {
	return float64(( /*line :300:17*/_Cfunc_greatCircleDistanceKm /*line :300:39*/)(a.toCPtr(), b.toCPtr()))
}

// PointDistM returns the "great circle" or "haversine" distance between pairs
// of LatLng points (lat/lng pairs) in meters.
func GreatCircleDistanceM(a, b LatLng) float64 {
	return float64(( /*line :306:17*/_Cfunc_greatCircleDistanceM /*line :306:38*/)(a.toCPtr(), b.toCPtr()))
}

// HexAreaKm2 returns the average hexagon area in square kilometers at the given
// resolution.
func HexagonAreaAvgKm2(resolution int) float64 {
	var out  /*line :312:10*/_Ctype_double /*line :312:18*/

	( /*line :314:2*/_Cfunc_getHexagonAreaAvgKm2 /*line :314:23*/)( /*line :314:25*/_Ctype_int /*line :314:30*/(resolution), &out)

	return float64(out)
}

// HexAreaM2 returns the average hexagon area in square meters at the given
// resolution.
func HexagonAreaAvgM2(resolution int) float64 {
	var out  /*line :322:10*/_Ctype_double /*line :322:18*/

	( /*line :324:2*/_Cfunc_getHexagonAreaAvgM2 /*line :324:22*/)( /*line :324:24*/_Ctype_int /*line :324:29*/(resolution), &out)

	return float64(out)
}

// CellAreaRads2 returns the exact area of specific cell in square radians.
func CellAreaRads2(c Cell) float64 {
	var out  /*line :331:10*/_Ctype_double /*line :331:18*/

	( /*line :333:2*/_Cfunc_cellAreaRads2 /*line :333:16*/)( /*line :333:18*/_Ctype_H3Index /*line :333:27*/(c), &out)

	return float64(out)
}

// CellAreaKm2 returns the exact area of specific cell in square kilometers.
func CellAreaKm2(c Cell) float64 {
	var out  /*line :340:10*/_Ctype_double /*line :340:18*/

	( /*line :342:2*/_Cfunc_cellAreaKm2 /*line :342:14*/)( /*line :342:16*/_Ctype_H3Index /*line :342:25*/(c), &out)

	return float64(out)
}

// CellAreaM2 returns the exact area of specific cell in square meters.
func CellAreaM2(c Cell) float64 {
	var out  /*line :349:10*/_Ctype_double /*line :349:18*/

	( /*line :351:2*/_Cfunc_cellAreaM2 /*line :351:13*/)( /*line :351:15*/_Ctype_H3Index /*line :351:24*/(c), &out)

	return float64(out)
}

// HexagonEdgeLengthAvgKm returns the average hexagon edge length in kilometers
// at the given resolution.
func HexagonEdgeLengthAvgKm(resolution int) float64 {
	var out  /*line :359:10*/_Ctype_double /*line :359:18*/

	( /*line :361:2*/_Cfunc_getHexagonEdgeLengthAvgKm /*line :361:28*/)( /*line :361:30*/_Ctype_int /*line :361:35*/(resolution), &out)

	return float64(out)
}

// HexagonEdgeLengthAvgM returns the average hexagon edge length in meters at
// the given resolution.
func HexagonEdgeLengthAvgM(resolution int) float64 {
	var out  /*line :369:10*/_Ctype_double /*line :369:18*/

	( /*line :371:2*/_Cfunc_getHexagonEdgeLengthAvgM /*line :371:27*/)( /*line :371:29*/_Ctype_int /*line :371:34*/(resolution), &out)

	return float64(out)
}

// EdgeLengthRads returns the exact edge length of specific unidirectional edge
// in radians.
func EdgeLengthRads(e DirectedEdge) float64 {
	var out  /*line :379:10*/_Ctype_double /*line :379:18*/

	( /*line :381:2*/_Cfunc_edgeLengthRads /*line :381:17*/)( /*line :381:19*/_Ctype_H3Index /*line :381:28*/(e), &out)

	return float64(out)
}

// EdgeLengthKm returns the exact edge length of specific unidirectional
// edge in kilometers.
func EdgeLengthKm(e DirectedEdge) float64 {
	var out  /*line :389:10*/_Ctype_double /*line :389:18*/

	( /*line :391:2*/_Cfunc_edgeLengthKm /*line :391:15*/)( /*line :391:17*/_Ctype_H3Index /*line :391:26*/(e), &out)

	return float64(out)
}

// EdgeLengthM returns the exact edge length of specific unidirectional
// edge in meters.
func EdgeLengthM(e DirectedEdge) float64 {
	var out  /*line :399:10*/_Ctype_double /*line :399:18*/

	( /*line :401:2*/_Cfunc_edgeLengthM /*line :401:14*/)( /*line :401:16*/_Ctype_H3Index /*line :401:25*/(e), &out)

	return float64(out)
}

// NumCells returns the number of cells at the given resolution.
func NumCells(resolution int) int {
	// NOTE: this is a mathematical operation, no need to call into H3 library.
	// See h3api.h for formula derivation.
	return 2 + 120*intPow(7, (resolution)) //nolint:gomnd // math formula
}

// Res0Cells returns all the cells at resolution 0.
func Res0Cells() []Cell {
	out := make([] /*line :415:16*/_Ctype_H3Index /*line :415:25*/, ( /*line :415:27*/_Cfunc_res0CellCount /*line :415:41*/)())
	( /*line :416:2*/_Cfunc_getRes0Cells /*line :416:15*/)(&out[0])

	return cellsFromC(out, false, false)
}

// Pentagons returns all the pentagons at resolution.
func Pentagons(resolution int) []Cell {
	out := make([] /*line :423:16*/_Ctype_H3Index /*line :423:25*/, NumPentagons)
	( /*line :424:2*/_Cfunc_getPentagons /*line :424:15*/)( /*line :424:17*/_Ctype_int /*line :424:22*/(resolution), &out[0])

	return cellsFromC(out, false, false)
}

func (c Cell) Resolution() int {
	return int(( /*line :430:13*/_Cfunc_getResolution /*line :430:27*/)( /*line :430:29*/_Ctype_H3Index /*line :430:38*/(c)))
}

func (e DirectedEdge) Resolution() int {
	return int(( /*line :434:13*/_Cfunc_getResolution /*line :434:27*/)( /*line :434:29*/_Ctype_H3Index /*line :434:38*/(e)))
}

// BaseCellNumber returns the integer ID (0-121) of the base cell the H3Index h
// belongs to.
func BaseCellNumber(h Cell) int {
	return int(( /*line :440:13*/_Cfunc_getBaseCellNumber /*line :440:31*/)( /*line :440:33*/_Ctype_H3Index /*line :440:42*/(h)))
}

// BaseCellNumber returns the integer ID (0-121) of the base cell the H3Index h
// belongs to.
func (c Cell) BaseCellNumber() int {
	return BaseCellNumber(c)
}

// IndexFromString returns a Cell from a string. Should call c.IsValid() to check
// if the Cell is valid before using it.
func IndexFromString(s string) uint64 {
	if len(s) > 2 && strings.ToLower(s[:2]) == "0x" {
		s = s[2:]
	}
	c, _ := strconv.ParseUint(s, base16, bitSize)

	return c
}

// IndexToString returns a Cell from a string. Should call c.IsValid() to check
// if the Cell is valid before using it.
func IndexToString(i uint64) string {
	return strconv.FormatUint(i, base16)
}

// String returns the string representation of the H3Index h.
func (c Cell) String() string {
	return IndexToString(uint64(c))
}

// MarshalText implements the encoding.TextMarshaler interface.
func (c Cell) MarshalText() ([]byte, error) {
	return []byte(c.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface.
func (c *Cell) UnmarshalText(text []byte) error {
	*c = Cell(IndexFromString(string(text)))
	if !c.IsValid() {
		return errors.New("invalid cell index")
	}

	return nil
}

// IsValid returns if a Cell is a valid cell (hexagon or pentagon).
func (c Cell) IsValid() bool {
	return c != 0 && ( /*line :488:19*/_Cfunc_isValidCell /*line :488:31*/)( /*line :488:33*/_Ctype_H3Index /*line :488:42*/(c)) == 1
}

// Parent returns the parent or grandparent Cell of this Cell.
func (c Cell) Parent(resolution int) Cell {
	var out  /*line :493:10*/_Ctype_H3Index /*line :493:19*/

	( /*line :495:2*/_Cfunc_cellToParent /*line :495:15*/)( /*line :495:17*/_Ctype_H3Index /*line :495:26*/(c),  /*line :495:31*/_Ctype_int /*line :495:36*/(resolution), &out)

	return Cell(out)
}

// Parent returns the parent or grandparent Cell of this Cell.
func (c Cell) ImmediateParent() Cell {
	return c.Parent(c.Resolution() - 1)
}

// Children returns the children or grandchildren cells of this Cell.
func (c Cell) Children(resolution int) []Cell {
	var outsz  /*line :507:12*/_Ctype_int64_t /*line :507:21*/

	( /*line :509:2*/_Cfunc_cellToChildrenSize /*line :509:21*/)( /*line :509:23*/_Ctype_H3Index /*line :509:32*/(c),  /*line :509:37*/_Ctype_int /*line :509:42*/(resolution), &outsz)
	out := make([] /*line :510:16*/_Ctype_H3Index /*line :510:25*/, outsz)

	( /*line :512:2*/_Cfunc_cellToChildren /*line :512:17*/)( /*line :512:19*/_Ctype_H3Index /*line :512:28*/(c),  /*line :512:33*/_Ctype_int /*line :512:38*/(resolution), &out[0])

	return cellsFromC(out, false, false)
}

// ImmediateChildren returns the children or grandchildren cells of this Cell.
func (c Cell) ImmediateChildren() []Cell {
	return c.Children(c.Resolution() + 1)
}

// CenterChild returns the center child Cell of this Cell.
func (c Cell) CenterChild(resolution int) Cell {
	var out  /*line :524:10*/_Ctype_H3Index /*line :524:19*/

	( /*line :526:2*/_Cfunc_cellToCenterChild /*line :526:20*/)( /*line :526:22*/_Ctype_H3Index /*line :526:31*/(c),  /*line :526:36*/_Ctype_int /*line :526:41*/(resolution), &out)

	return Cell(out)
}

// IsResClassIII returns true if this is a class III index. If false, this is a
// class II index.
func (c Cell) IsResClassIII() bool {
	return ( /*line :534:9*/_Cfunc_isResClassIII /*line :534:23*/)( /*line :534:25*/_Ctype_H3Index /*line :534:34*/(c)) == 1
}

// IsPentagon returns true if this is a pentagon.
func (c Cell) IsPentagon() bool {
	return ( /*line :539:9*/_Cfunc_isPentagon /*line :539:20*/)( /*line :539:22*/_Ctype_H3Index /*line :539:31*/(c)) == 1
}

// IcosahedronFaces finds all icosahedron faces (0-19) intersected by this Cell.
func (c Cell) IcosahedronFaces() []int {
	var outsz  /*line :544:12*/_Ctype_int /*line :544:17*/

	( /*line :546:2*/_Cfunc_maxFaceCount /*line :546:15*/)( /*line :546:17*/_Ctype_H3Index /*line :546:26*/(c), &outsz)
	out := make([] /*line :547:16*/_Ctype_int /*line :547:21*/, outsz)

	( /*line :549:2*/_Cfunc_getIcosahedronFaces /*line :549:22*/)( /*line :549:24*/_Ctype_H3Index /*line :549:33*/(c), &out[0])

	return intsFromC(out)
}

// IsNeighbor returns true if this Cell is a neighbor of the other Cell.
func (c Cell) IsNeighbor(other Cell) bool {
	var out  /*line :556:10*/_Ctype_int /*line :556:15*/
	( /*line :557:2*/_Cfunc_areNeighborCells /*line :557:19*/)( /*line :557:21*/_Ctype_H3Index /*line :557:30*/(c),  /*line :557:35*/_Ctype_H3Index /*line :557:44*/(other), &out)

	return out == 1
}

// DirectedEdge returns a DirectedEdge from this Cell to other.
func (c Cell) DirectedEdge(other Cell) DirectedEdge {
	var out  /*line :564:10*/_Ctype_H3Index /*line :564:19*/
	( /*line :565:2*/_Cfunc_cellsToDirectedEdge /*line :565:22*/)( /*line :565:24*/_Ctype_H3Index /*line :565:33*/(c),  /*line :565:38*/_Ctype_H3Index /*line :565:47*/(other), &out)

	return DirectedEdge(out)
}

// DirectedEdges returns 6 directed edges with h as the origin.
func (c Cell) DirectedEdges() []DirectedEdge {
	out := make([] /*line :572:16*/_Ctype_H3Index /*line :572:25*/, numCellEdges) // always 6 directed edges
	( /*line :573:2*/_Cfunc_originToDirectedEdges /*line :573:24*/)( /*line :573:26*/_Ctype_H3Index /*line :573:35*/(c), &out[0])

	return edgesFromC(out)
}

func (e DirectedEdge) IsValid() bool {
	return ( /*line :579:9*/_Cfunc_isValidDirectedEdge /*line :579:29*/)( /*line :579:31*/_Ctype_H3Index /*line :579:40*/(e)) == 1
}

// Origin returns the origin cell of this directed edge.
func (e DirectedEdge) Origin() Cell {
	var out  /*line :584:10*/_Ctype_H3Index /*line :584:19*/
	( /*line :585:2*/_Cfunc_getDirectedEdgeOrigin /*line :585:24*/)( /*line :585:26*/_Ctype_H3Index /*line :585:35*/(e), &out)

	return Cell(out)
}

// Destination returns the destination cell of this directed edge.
func (e DirectedEdge) Destination() Cell {
	var out  /*line :592:10*/_Ctype_H3Index /*line :592:19*/
	( /*line :593:2*/_Cfunc_getDirectedEdgeDestination /*line :593:29*/)( /*line :593:31*/_Ctype_H3Index /*line :593:40*/(e), &out)

	return Cell(out)
}

// Cells returns the origin and destination cells in that order.
func (e DirectedEdge) Cells() []Cell {
	out := make([] /*line :600:16*/_Ctype_H3Index /*line :600:25*/, numEdgeCells)
	( /*line :601:2*/_Cfunc_directedEdgeToCells /*line :601:22*/)( /*line :601:24*/_Ctype_H3Index /*line :601:33*/(e), &out[0])

	return cellsFromC(out, false, false)
}

// Boundary provides the coordinates of the boundary of the directed edge. Note,
// the type returned is CellBoundary, but the coordinates will be from the
// center of the origin to the center of the destination. There may be more than
// 2 coordinates to account for crossing faces.
func (e DirectedEdge) Boundary() CellBoundary {
	var out  /*line :611:10*/_Ctype_CellBoundary /*line :611:24*/
	( /*line :612:2*/_Cfunc_directedEdgeToBoundary /*line :612:25*/)( /*line :612:27*/_Ctype_H3Index /*line :612:36*/(e), &out)

	return cellBndryFromC(&out)
}

// CompactCells merges full sets of children into their parent H3Index
// recursively, until no more merges are possible.
func CompactCells(in []Cell) []Cell {
	cin := cellsToC(in)
	csz :=  /*line :621:9*/_Ctype_int64_t /*line :621:18*/(len(in))
	// worst case no compaction so we need a set **at least** as large as the
	// input
	cout := make([] /*line :624:17*/_Ctype_H3Index /*line :624:26*/, csz)
	( /*line :625:2*/_Cfunc_compactCells /*line :625:15*/)(&cin[0], &cout[0], csz)

	return cellsFromC(cout, false, true)
}

// UncompactCells splits every H3Index in in if its resolution is greater
// than resolution recursively. Returns all the H3Indexes at resolution resolution.
func UncompactCells(in []Cell, resolution int) []Cell {
	cin := cellsToC(in)
	var csz  /*line :634:10*/_Ctype_int64_t /*line :634:19*/
	( /*line :635:2*/_Cfunc_uncompactCellsSize /*line :635:21*/)(&cin[0],  /*line :635:32*/_Ctype_int64_t /*line :635:41*/(len(cin)),  /*line :635:53*/_Ctype_int /*line :635:58*/(resolution), &csz)

	cout := make([] /*line :637:17*/_Ctype_H3Index /*line :637:26*/, csz)
	( /*line :638:2*/_Cfunc_uncompactCells /*line :638:17*/)(
		&cin[0],  /*line :639:12*/_Ctype_int64_t /*line :639:21*/(len(in)),
		&cout[0], csz,
		 /*line :641:3*/_Ctype_int /*line :641:8*/(resolution))

	return cellsFromC(cout, false, true)
}

// ChildPosToCell returns the child of cell a at a given position within an ordered list of all
// children at the specified resolution.
func ChildPosToCell(position int, a Cell, resolution int) Cell {
	var out  /*line :649:10*/_Ctype_H3Index /*line :649:19*/

	( /*line :651:2*/_Cfunc_childPosToCell /*line :651:17*/)( /*line :651:19*/_Ctype_int64_t /*line :651:28*/(position),  /*line :651:40*/_Ctype_H3Index /*line :651:49*/(a),  /*line :651:54*/_Ctype_int /*line :651:59*/(resolution), &out)

	return Cell(out)
}

// ChildPosToCell returns the child cell at a given position within an ordered list of all
// children at the specified resolution.
func (c Cell) ChildPosToCell(position int, resolution int) Cell {
	return ChildPosToCell(position, c, resolution)
}

// CellToChildPos returns the position of the cell a within an ordered list of all children of the cell's parent
// at the specified resolution.
func CellToChildPos(a Cell, resolution int) int {
	var out  /*line :665:10*/_Ctype_int64_t /*line :665:19*/

	( /*line :667:2*/_Cfunc_cellToChildPos /*line :667:17*/)( /*line :667:19*/_Ctype_H3Index /*line :667:28*/(a),  /*line :667:33*/_Ctype_int /*line :667:38*/(resolution), &out)

	return int(out)
}

// ChildPos returns the position of the cell within an ordered list of all children of the cell's parent
// at the specified resolution.
func (c Cell) ChildPos(resolution int) int {
	return CellToChildPos(c, resolution)
}

func GridDistance(a, b Cell) int {
	var out  /*line :679:10*/_Ctype_int64_t /*line :679:19*/
	( /*line :680:2*/_Cfunc_gridDistance /*line :680:15*/)( /*line :680:17*/_Ctype_H3Index /*line :680:26*/(a),  /*line :680:31*/_Ctype_H3Index /*line :680:40*/(b), &out)

	return int(out)
}

func (c Cell) GridDistance(other Cell) int {
	return GridDistance(c, other)
}

func GridPath(a, b Cell) []Cell {
	var outsz  /*line :690:12*/_Ctype_int64_t /*line :690:21*/
	( /*line :691:2*/_Cfunc_gridPathCellsSize /*line :691:20*/)( /*line :691:22*/_Ctype_H3Index /*line :691:31*/(a),  /*line :691:36*/_Ctype_H3Index /*line :691:45*/(b), &outsz)

	out := make([] /*line :693:16*/_Ctype_H3Index /*line :693:25*/, outsz)
	( /*line :694:2*/_Cfunc_gridPathCells /*line :694:16*/)( /*line :694:18*/_Ctype_H3Index /*line :694:27*/(a),  /*line :694:32*/_Ctype_H3Index /*line :694:41*/(b), &out[0])

	return cellsFromC(out, false, false)
}

func (c Cell) GridPath(other Cell) []Cell {
	return GridPath(c, other)
}

func CellToLocalIJ(origin, cell Cell) CoordIJ {
	var out  /*line :704:10*/_Ctype_CoordIJ /*line :704:19*/
	( /*line :705:2*/_Cfunc_cellToLocalIj /*line :705:16*/)( /*line :705:18*/_Ctype_H3Index /*line :705:27*/(origin),  /*line :705:37*/_Ctype_H3Index /*line :705:46*/(cell), 0, &out)

	return CoordIJ{int(out.i), int(out.j)}
}

func LocalIJToCell(origin Cell, ij CoordIJ) Cell {
	var out  /*line :711:10*/_Ctype_H3Index /*line :711:19*/
	( /*line :712:2*/_Cfunc_localIjToCell /*line :712:16*/)( /*line :712:18*/_Ctype_H3Index /*line :712:27*/(origin), ij.toCPtr(), 0, &out)

	return Cell(out)
}

func CellToVertex(c Cell, vertexNum int) Cell {
	var out  /*line :718:10*/_Ctype_H3Index /*line :718:19*/
	( /*line :719:2*/_Cfunc_cellToVertex /*line :719:15*/)( /*line :719:17*/_Ctype_H3Index /*line :719:26*/(c),  /*line :719:31*/_Ctype_int /*line :719:36*/(vertexNum), &out)

	return Cell(out)
}

func CellToVertexes(c Cell) []Cell {
	out := make([] /*line :725:16*/_Ctype_H3Index /*line :725:25*/, numCellVertexes)
	( /*line :726:2*/_Cfunc_cellToVertexes /*line :726:17*/)( /*line :726:19*/_Ctype_H3Index /*line :726:28*/(c), &out[0])

	return cellsFromC(out, true, false)
}

func VertexToLatLng(vertex Cell) LatLng {
	var out  /*line :732:10*/_Ctype_LatLng /*line :732:18*/
	( /*line :733:2*/_Cfunc_vertexToLatLng /*line :733:17*/)( /*line :733:19*/_Ctype_H3Index /*line :733:28*/(vertex), &out)

	return latLngFromC(out)
}

func IsValidVertex(c Cell) bool {
	return ( /*line :739:9*/_Cfunc_isValidVertex /*line :739:23*/)( /*line :739:25*/_Ctype_H3Index /*line :739:34*/(c)) == 1
}

func maxGridDiskSize(k int) int {
	return 3*k*(k+1) + 1
}

func latLngFromC(cg  /*line :746:21*/_Ctype_LatLng /*line :746:29*/) LatLng {
	g := LatLng{}
	g.Lat = RadsToDegs * float64(cg.lat)
	g.Lng = RadsToDegs * float64(cg.lng)

	return g
}

func cellBndryFromC(cb * /*line :754:25*/_Ctype_CellBoundary /*line :754:39*/) CellBoundary {
	g := make(CellBoundary, 0, MaxCellBndryVerts)
	for i :=  /*line :756:11*/_Ctype_int /*line :756:16*/(0); i < cb.numVerts; i++ {
		g = append(g, latLngFromC(cb.verts[i]))
	}

	return g
}

func ringSize(k int) int {
	if k == 0 {
		return 1
	}

	return 6 * k //nolint:gomnd // math formula
}

// Convert slice of LatLngs to an array of C LatLngs (represented in C-style as
// a pointer to the first item in the array). The caller must free the returned
// pointer when finished with it.
func latLngsToC(coords []LatLng) * /*line :774:35*/_Ctype_LatLng /*line :774:43*/ {
	if len(coords) == 0 {
		return nil
	}

	// Use malloc to construct a C-style struct array for the output
	cverts := ( /*line :780:12*/_Cfunc__CMalloc /*line :780:19*/)( /*line :780:21*/_Ctype_size_t /*line :780:29*/(( /*line :780:30*/_Ciconst_sizeof_LatLng /*line :780:44*/) * len(coords)))
	pv := cverts

	for _, gc := range coords {
		*((* /*line :784:7*/_Ctype_LatLng /*line :784:15*/)(pv)) = *gc.toCPtr()
		pv = unsafe.Pointer(uintptr(pv) + ( /*line :785:37*/_Ciconst_sizeof_LatLng /*line :785:51*/))
	}

	return (* /*line :788:11*/_Ctype_LatLng /*line :788:19*/)(cverts)
}

// Convert geofences (slices of slices of LatLnginates) to C geofences (represented in C-style as
// a pointer to the first item in the array). The caller must free the returned pointer and any
// pointer on the verts field when finished using it.
func geoLoopsToC(geofences []GeoLoop) * /*line :794:40*/_Ctype_GeoLoop /*line :794:49*/ {
	if len(geofences) == 0 {
		return nil
	}

	// Use malloc to construct a C-style struct array for the output
	cgeofences := ( /*line :800:16*/_Cfunc__CMalloc /*line :800:23*/)( /*line :800:25*/_Ctype_size_t /*line :800:33*/(( /*line :800:34*/_Ciconst_sizeof_GeoLoop /*line :800:49*/) * len(geofences)))

	pcgeofences := cgeofences

	for _, coords := range geofences {
		cverts := latLngsToC(coords)

		*((* /*line :807:7*/_Ctype_GeoLoop /*line :807:16*/)(pcgeofences)) =  /*line :807:34*/_Ctype_GeoLoop /*line :807:43*/{
			verts:    cverts,
			numVerts:  /*line :809:14*/_Ctype_int /*line :809:19*/(len(coords)),
		}
		pcgeofences = unsafe.Pointer(uintptr(pcgeofences) + ( /*line :811:55*/_Ciconst_sizeof_GeoLoop /*line :811:70*/))
	}

	return (* /*line :814:11*/_Ctype_GeoLoop /*line :814:20*/)(cgeofences)
}

// Convert GeoPolygon struct to C equivalent struct.
func allocCGeoPolygon(gp GeoPolygon)  /*line :818:38*/_Ctype_GeoPolygon /*line :818:50*/ {
	cverts := latLngsToC(gp.GeoLoop)
	choles := geoLoopsToC(gp.Holes)

	return  /*line :822:9*/_Ctype_GeoPolygon /*line :822:21*/{
		geoloop:  /*line :823:12*/_Ctype_GeoLoop /*line :823:21*/{
			numVerts:  /*line :824:14*/_Ctype_int /*line :824:19*/(len(gp.GeoLoop)),
			verts:    cverts,
		},
		numHoles:  /*line :827:13*/_Ctype_int /*line :827:18*/(len(gp.Holes)),
		holes:    choles,
	}
}

// Free pointer values on a C GeoPolygon struct
func freeCGeoPolygon(cgp * /*line :833:27*/_Ctype_GeoPolygon /*line :833:39*/) {
	func() { _cgo0 := /*line :834:9*/unsafe.Pointer(cgp.geoloop.verts); _cgoCheckPointer(_cgo0, nil); /*line :834:43*/_Cfunc_free(_cgo0); }()
	cgp.geoloop.verts = nil

	ph := unsafe.Pointer(cgp.holes)

	for i :=  /*line :839:11*/_Ctype_int /*line :839:16*/(0); i < cgp.numHoles; i++ {
		func() { _cgo0 := /*line :840:10*/unsafe.Pointer((*_Ctype_GeoLoop /*line :840:36*/)(ph).verts); _cgoCheckPointer(_cgo0, nil); /*line :840:49*/_Cfunc_free(_cgo0); }()
		(* /*line :841:5*/_Ctype_GeoLoop /*line :841:14*/)(ph).verts = nil
		ph = unsafe.Pointer(uintptr(ph) + uintptr(( /*line :842:45*/_Ciconst_sizeof_GeoLoop /*line :842:60*/)))
	}

	func() { _cgo0 := /*line :845:9*/unsafe.Pointer(cgp.holes); _cgoCheckPointer(_cgo0, nil); /*line :845:35*/_Cfunc_free(_cgo0); }()
	cgp.holes = nil
}

// https://stackoverflow.com/questions/64108933/how-to-use-math-pow-with-integers-in-golang
func intPow(n, m int) int {
	if m == 0 {
		return 1
	}
	result := n

	for i := 2; i <= m; i++ {
		result *= n
	}

	return result
}

func cellsFromC(chs [] /*line :863:23*/_Ctype_H3Index /*line :863:32*/, prune, refit bool) []Cell {
	// OPT: This could be more efficient if we unsafely cast the C array to a
	// []H3Index.
	out := make([]Cell, 0, len(chs))

	for i := range chs {
		if prune && chs[i] <= 0 {
			continue
		}

		out = append(out, Cell(chs[i]))
	}

	if refit {
		// Some algorithms require a maximum sized array, but only use a subset
		// of the memory.  refit sizes the slice to the last non-empty element.
		for i := len(out) - 1; i >= 0; i-- {
			if out[i] == 0 {
				out = out[:i]
			}
		}
	}

	return out
}

func edgesFromC(chs [] /*line :889:23*/_Ctype_H3Index /*line :889:32*/) []DirectedEdge {
	out := make([]DirectedEdge, 0, len(chs))

	for i := range chs {
		if chs[i] <= 0 {
			continue
		}

		out = append(out, DirectedEdge(chs[i]))
	}

	return out
}

func cellsToC(chs []Cell) [] /*line :903:29*/_Ctype_H3Index /*line :903:38*/ {
	// OPT: This could be more efficient if we unsafely cast the array to a
	// []C.H3Index.
	out := make([] /*line :906:16*/_Ctype_H3Index /*line :906:25*/, len(chs))
	for i := range chs {
		out[i] =  /*line :908:12*/_Ctype_H3Index /*line :908:21*/(chs[i])
	}

	return out
}

func intsFromC(chs [] /*line :914:22*/_Ctype_int /*line :914:27*/) []int {
	out := make([]int, 0, len(chs))

	for i := range chs {
		// C API returns a sparse array of indexes in the event pentagons and
		// deleted sequences are encountered.
		if chs[i] != -1 {
			out = append(out, int(chs[i]))
		}
	}

	return out
}

func (g LatLng) String() string {
	return fmt.Sprintf("(%.5f, %.5f)", g.Lat, g.Lng)
}

func (g LatLng) toCPtr() * /*line :932:27*/_Ctype_LatLng /*line :932:35*/ {
	return & /*line :933:10*/_Ctype_LatLng /*line :933:18*/{
		lat:  /*line :934:8*/_Ctype_double /*line :934:16*/(DegsToRads * g.Lat),
		lng:  /*line :935:8*/_Ctype_double /*line :935:16*/(DegsToRads * g.Lng),
	}
}

func (ij CoordIJ) toCPtr() * /*line :939:29*/_Ctype_CoordIJ /*line :939:38*/ {
	return & /*line :940:10*/_Ctype_CoordIJ /*line :940:19*/{
		i:  /*line :941:6*/_Ctype_int /*line :941:11*/(ij.I),
		j:  /*line :942:6*/_Ctype_int /*line :942:11*/(ij.J),
	}
}
